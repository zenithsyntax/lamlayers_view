import 'dart:async';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'package:http/http.dart' as http;
import 'package:google_sign_in/google_sign_in.dart';
import 'package:googleapis/drive/v3.dart' as drive;
import 'package:go_router/go_router.dart';
import 'lambook_reader_screen.dart';
import 'privacy_policy_screen.dart';
import 'terms_of_service_screen.dart';
import 'data_deletion_screen.dart';
import 'home_screen.dart';

void main() {
  runApp(const MyApp());
}

class _GoogleAuthClient extends http.BaseClient {
  final Map<String, String> _headers;
  final http.Client _inner = http.Client();
  _GoogleAuthClient(this._headers);
  @override
  Future<http.StreamedResponse> send(http.BaseRequest request) {
    request.headers.addAll(_headers);
    return _inner.send(request);
  }
}

final GoRouter _router = GoRouter(
  initialLocation: '/',
  routes: [
    GoRoute(path: '/', builder: (context, state) => const HomeScreen()),
    GoRoute(path: '/home', builder: (context, state) => const HomeScreen()),
    GoRoute(
      path: '/lambook-view',
      builder: (context, state) {
        final fileUrl = state.uri.queryParameters['file'];
        return ViewerHomePage(fileUrl: fileUrl);
      },
    ),
    GoRoute(
      path: '/terms',
      builder: (context, state) => const TermsOfServiceScreen(),
    ),
    GoRoute(
      path: '/privacy',
      builder: (context, state) => const PrivacyPolicyScreen(),
    ),
    GoRoute(
      path: '/data_deletion',
      builder: (context, state) => const DataDeletionScreen(),
    ),
  ],
);

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ScreenUtilInit(
      designSize: const Size(390, 844),
      minTextAdapt: true,
      splitScreenMode: true,
      builder: (context, child) {
        return MaterialApp.router(
          title: 'Lamlayers - Digital Lambook Viewer',
          theme: ThemeData(
            colorScheme: ColorScheme.fromSeed(
              seedColor: Colors.indigo,
              brightness: Brightness.light,
            ),
            useMaterial3: true,
            cardTheme: CardThemeData(
              elevation: 0,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
            ),
          ),
          routerConfig: _router,
        );
      },
    );
  }
}

class ViewerHomePage extends StatefulWidget {
  final String? fileUrl;

  const ViewerHomePage({super.key, this.fileUrl});

  @override
  State<ViewerHomePage> createState() => _ViewerHomePageState();
}

class _ViewerHomePageState extends State<ViewerHomePage>
    with SingleTickerProviderStateMixin {
  String? fileUrl;
  Uint8List? fileBytes;
  String? error;
  bool loading = true;
  String loadingMessage = 'Loading...';

  double downloadProgress = 0.0;
  int downloadedBytes = 0;
  int totalBytes = 0;
  bool isDownloading = false;

  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;

  static const String _webClientId =
      '95582377829-f64u9joo19djd769u06mp3719hh2vg1l.apps.googleusercontent.com';

  // Use redirect-based sign in for web to avoid popup blockers
  final GoogleSignIn _gsignIn = GoogleSignIn(
    clientId: _webClientId,
    scopes: <String>['https://www.googleapis.com/auth/drive.file'],
    // Force redirect flow on web to avoid popups
    signInOption: SignInOption.standard,
  );

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeInOut,
    );
    _animationController.forward();
    _loadFromQuery();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  String _formatBytes(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(2)} KB';
    if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(2)} MB';
    }
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';
  }

  Future<void> _loadFromQuery() async {
    try {
      final param = widget.fileUrl;
      if (param == null || param.isEmpty) {
        setState(() {
          loading = false;
          error = 'No file specified';
        });
        return;
      }
      setState(() {
        fileUrl = param;
      });
      if (_isGoogleDriveUrl(param)) {
        // Try silent sign-in first
        await _attemptSilentSignIn();
      } else {
        await _downloadDirectUrl(param);
      }
    } catch (e) {
      setState(() {
        loading = false;
        error = 'Error: $e';
        isDownloading = false;
      });
    }
  }

  Future<void> _attemptSilentSignIn() async {
    setState(() {
      loading = true;
      loadingMessage = 'Checking for existing credentials...';
    });

    try {
      final user = await _gsignIn.signInSilently(suppressErrors: true);
      
      if (user != null) {
        // User is already signed in, proceed to download
        print('Silent sign-in successful');
        await _downloadFromDrive();
      } else {
        // No existing credentials, show sign-in button
        print('Silent sign-in failed, showing sign-in button');
        setState(() {
          loading = false;
          loadingMessage = 'Loading...';
        });
      }
    } catch (e) {
      print('Silent sign-in error: $e');
      setState(() {
        loading = false;
        loadingMessage = 'Loading...';
      });
    }
  }

  Future<void> _downloadDirectUrl(String url) async {
    setState(() {
      isDownloading = true;
      downloadProgress = 0.0;
      downloadedBytes = 0;
      totalBytes = 0;
    });

    try {
      final request = http.Request('GET', Uri.parse(url));
      final response = await request.send();

      if (response.statusCode != 200) {
        setState(() {
          loading = false;
          isDownloading = false;
          error = 'Unable to download file';
        });
        return;
      }

      totalBytes = response.contentLength ?? 0;
      final chunks = <int>[];

      await for (var chunk in response.stream) {
        chunks.addAll(chunk);
        downloadedBytes = chunks.length;

        if (!mounted) return;

        setState(() {
          if (totalBytes > 0) {
            downloadProgress = downloadedBytes / totalBytes;
          }
        });
      }

      if (chunks.isEmpty) {
        setState(() {
          loading = false;
          isDownloading = false;
          error = 'Downloaded file is empty';
        });
        return;
      }

      setState(() {
        fileBytes = Uint8List.fromList(chunks);
        loading = false;
        isDownloading = false;
        downloadProgress = 1.0;
      });

      _openReaderIfReady();
    } catch (e) {
      setState(() {
        loading = false;
        isDownloading = false;
        error = 'Download failed';
      });
    }
  }

  void _openReaderIfReady() {
    if (mounted && fileUrl != null && fileBytes != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        Navigator.of(context).push(
          MaterialPageRoute(
            builder: (_) =>
                LambookReaderScreen(fileUrl: fileUrl!, bytes: fileBytes!),
          ),
        );
      });
    }
  }

  Future<void> _signInAndLoadDrive() async {
    final url = fileUrl;
    if (url == null) return;

    setState(() {
      loading = true;
      error = null;
      loadingMessage = 'Connecting to Google...';
    });

    try {
      // Use standard sign-in which will redirect instead of popup
      final user = await _gsignIn.signIn();

      if (user == null) {
        // User cancelled the sign-in
        setState(() {
          loading = false;
          loadingMessage = 'Loading...';
          error = 'Sign-in was cancelled. Please try again.';
        });
        return;
      }

      // Check and request scopes if needed
      const scopes = <String>['https://www.googleapis.com/auth/drive.file'];
      final hasScope = await _gsignIn.canAccessScopes(scopes);

      if (!hasScope) {
        setState(() => loadingMessage = 'Requesting permissions...');
        final granted = await _gsignIn.requestScopes(scopes);
        
        if (!granted) {
          setState(() {
            loading = false;
            loadingMessage = 'Loading...';
            error = 'Drive access permission denied';
          });
          return;
        }
      }

      // Proceed to download
      await _downloadFromDrive();

    } catch (e) {
      print('Sign-in error: $e');
      
      String errorMessage;
      if (e.toString().contains('popup_closed') ||
          e.toString().contains('popup_blocked_by_browser')) {
        errorMessage = 'Sign-in window was closed. Please try again.';
      } else if (e.toString().contains('access_denied')) {
        errorMessage = 'Access denied. Please grant permissions.';
      } else if (e.toString().contains('network')) {
        errorMessage = 'Network error. Check your connection.';
      } else {
        errorMessage = 'Sign-in failed. Please try again.';
      }

      setState(() {
        loading = false;
        loadingMessage = 'Loading...';
        error = errorMessage;
      });
    }
  }

  Future<void> _downloadFromDrive() async {
    final url = fileUrl;
    if (url == null) return;

    try {
      setState(() => loadingMessage = 'Connecting to Drive...');

      final headers = await _gsignIn.currentUser!.authHeaders;
      final api = drive.DriveApi(_GoogleAuthClient(headers));

      setState(() => loadingMessage = 'Checking file...');

      final id = _extractDriveFileId(url);

      // Get file metadata first
      drive.File fileMetadata;
      try {
        fileMetadata = await api.files.get(
          id,
          $fields: 'id,name,size,mimeType,capabilities',
        ) as drive.File;
        
        print('File metadata: ${fileMetadata.toJson()}');
        
      } catch (e) {
        print('Error getting file metadata: $e');
        
        String errorMsg = 'Cannot access file';
        
        if (e.toString().contains('403')) {
          errorMsg = 'Access denied (403). This file cannot be accessed.\n\n'
                     'Possible reasons:\n'
                     '• File was not created by this app\n'
                     '• File was not explicitly opened with this app\n'
                     '• Insufficient permissions\n\n'
                     'Solution: Ask the file owner to share it with your Google account.';
        } else if (e.toString().contains('404')) {
          errorMsg = 'File not found (404). The file may have been deleted or the link is incorrect.';
        } else if (e.toString().contains('401')) {
          errorMsg = 'Authentication failed (401). Please sign in again.';
        }
        
        setState(() {
          loading = false;
          loadingMessage = 'Loading...';
          isDownloading = false;
          error = errorMsg;
        });
        return;
      }

      final fileSize = int.tryParse(fileMetadata.size ?? '0') ?? 0;
      print('File size: $fileSize bytes');

      // Check if file is too large (over 500MB)
      if (fileSize > 500 * 1024 * 1024) {
        setState(() {
          loading = false;
          loadingMessage = 'Loading...';
          isDownloading = false;
          error = 'File is too large (${(fileSize / (1024 * 1024)).toStringAsFixed(0)} MB).\n\n'
                 'Maximum supported size is 500 MB.';
        });
        return;
      }

      setState(() {
        totalBytes = fileSize;
        isDownloading = true;
        downloadProgress = 0.0;
        downloadedBytes = 0;
        loadingMessage = 'Starting download...';
      });

      // Download the file
      try {
        print('Starting file download...');
        
        final media = await api.files.get(
          id,
          downloadOptions: drive.DownloadOptions.fullMedia,
        ) as drive.Media;

        print('Got media stream, reading chunks...');

        final List<List<int>> chunksList = [];
        int lastUpdateTime = DateTime.now().millisecondsSinceEpoch;
        int totalDownloaded = 0;
        
        await for (var chunk in media.stream) {
          if (!mounted) return;
          
          chunksList.add(chunk);
          totalDownloaded += chunk.length;
          downloadedBytes = totalDownloaded;

          final currentTime = DateTime.now().millisecondsSinceEpoch;
          
          if (currentTime - lastUpdateTime > 300) {
            lastUpdateTime = currentTime;
            
            if (mounted) {
              setState(() {
                if (totalBytes > 0) {
                  downloadProgress = downloadedBytes / totalBytes;
                }
                loadingMessage = 'Downloading... ${(downloadProgress * 100).toStringAsFixed(0)}%';
              });
            }
          }
        }
        
        print('Stream completed. Total bytes: $totalDownloaded');

        if (chunksList.isEmpty) {
          setState(() {
            loading = false;
            loadingMessage = 'Loading...';
            isDownloading = false;
            error = 'Downloaded file is empty.';
          });
          return;
        }

        print('Combining chunks...');
        if (!mounted) return;
        
        setState(() {
          loadingMessage = 'Processing file...';
        });

        // Combine chunks
        int totalSize = 0;
        for (var chunk in chunksList) {
          totalSize += chunk.length;
        }
        
        final fileData = Uint8List(totalSize);
        int offset = 0;
        for (var chunk in chunksList) {
          fileData.setRange(offset, offset + chunk.length, chunk);
          offset += chunk.length;
        }

        if (!mounted) return;

        setState(() {
          fileBytes = fileData;
          loading = false;
          loadingMessage = 'Loading...';
          isDownloading = false;
          downloadProgress = 1.0;
          error = null;
        });

        print('Opening reader...');
        _openReaderIfReady();
        
      } catch (downloadError) {
        print('Download error: $downloadError');
        
        String errorMsg = 'Download failed';
        
        if (downloadError.toString().contains('403')) {
          errorMsg = 'Permission denied (403). Cannot download this file.';
        } else if (downloadError.toString().contains('404')) {
          errorMsg = 'File not found (404) during download.';
        } else if (downloadError.toString().contains('network') || 
                   downloadError.toString().contains('connection')) {
          errorMsg = 'Network error. Please check your connection.';
        } else if (downloadError.toString().contains('timeout')) {
          errorMsg = 'Download timed out. The file may be too large.';
        } else {
          errorMsg = 'Download failed: ${downloadError.toString()}';
        }
        
        setState(() {
          loading = false;
          loadingMessage = 'Loading...';
          isDownloading = false;
          error = errorMsg;
        });
      }
      
    } catch (e) {
      print('General error: $e');
      
      setState(() {
        loading = false;
        loadingMessage = 'Loading...';
        isDownloading = false;
        error = 'Error loading file: ${e.toString()}';
      });
    }
  }

  bool _isGoogleDriveUrl(String input) {
    final u = Uri.tryParse(input);
    if (u == null) return false;
    final host = u.host.toLowerCase();
    return host.contains('drive.google.com') || host.contains('docs.google.com');
  }

  String _extractDriveFileId(String input) {
    final uri = Uri.tryParse(input);
    if (uri == null) return input;
    
    final idParam = uri.queryParameters['id'];
    if (idParam != null && idParam.isNotEmpty) return idParam;
    
    final m = RegExp(r'/file/d/([^/]+)').firstMatch(uri.path);
    if (m != null) return m.group(1)!;
    
    final m2 = RegExp(r'/d/([^/]+)').firstMatch(uri.path);
    if (m2 != null) return m2.group(1)!;
    
    return input;
  }

  Widget _buildDownloadingView() {
    final downloadedMB = totalBytes > 0 
        ? (downloadedBytes / (1024 * 1024)).toStringAsFixed(1)
        : '0.0';
    final totalMB = totalBytes > 0 
        ? (totalBytes / (1024 * 1024)).toStringAsFixed(1)
        : '0.0';
    final percentageText = totalBytes > 0 
        ? (downloadProgress * 100).toStringAsFixed(1)
        : '0.0';

    return FadeTransition(
      opacity: _fadeAnimation,
      child: Container(
        constraints: const BoxConstraints(maxWidth: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TweenAnimationBuilder<double>(
              tween: Tween(begin: 0.0, end: 1.0),
              duration: const Duration(seconds: 2),
              builder: (context, value, child) {
                return Container(
                  padding: const EdgeInsets.all(24),
                  decoration: BoxDecoration(
                    color: Colors.indigo.withOpacity(0.1),
                    shape: BoxShape.circle,
                  ),
                  child: Transform.rotate(
                    angle: value * 6.28,
                    child: const Icon(
                      Icons.cloud_download_rounded,
                      size: 64,
                      color: Colors.indigo,
                    ),
                  ),
                );
              },
              onEnd: () {
                if (mounted && isDownloading) {
                  setState(() {});
                }
              },
            ),
            const SizedBox(height: 32),
            
            Text(
              'Downloading Your Lambook',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: Colors.grey[800],
                  ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: 16,
                vertical: 8,
              ),
              decoration: BoxDecoration(
                color: Colors.indigo.shade50,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                'Downloading...',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: Colors.indigo,
                    ),
              ),
            ),
            const SizedBox(height: 24),
            
            if (totalBytes > 0) ...[
              Text(
                '$downloadedMB MB of $totalMB MB',
                style: Theme.of(context).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: Colors.indigo,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 20),
            ],
            
            Container(
              width: double.infinity,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.indigo.withOpacity(0.1),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: Stack(
                  children: [
                    Container(
                      height: 24,
                      color: Colors.grey[200],
                    ),
                    FractionallySizedBox(
                      widthFactor: downloadProgress,
                      child: Container(
                        height: 24,
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              Colors.indigo,
                              Colors.indigo.shade300,
                            ],
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 12),
            
            Text(
              '$percentageText%',
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: Colors.grey[700],
                  ),
            ),
            const SizedBox(height: 32),
            
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: Colors.amber[50],
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: Colors.amber.shade200),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.info_outline_rounded,
                    color: Colors.amber[800],
                    size: 24,
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Please wait',
                          style: Theme.of(context)
                              .textTheme
                              .bodyLarge
                              ?.copyWith(
                                color: Colors.amber[900],
                                fontWeight: FontWeight.w700,
                              ),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          'Keep this page open. Don\'t switch apps or lock your device.',
                          style: Theme.of(context)
                              .textTheme
                              .bodyMedium
                              ?.copyWith(
                                color: Colors.amber[900],
                                fontWeight: FontWeight.w500,
                                height: 1.4,
                              ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLoadingView() {
    return FadeTransition(
      opacity: _fadeAnimation,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Stack(
            alignment: Alignment.center,
            children: [
              SizedBox(
                width: 80,
                height: 80,
                child: CircularProgressIndicator(
                  strokeWidth: 3,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    Colors.indigo.shade300,
                  ),
                ),
              ),
              Icon(
                Icons.menu_book_rounded,
                size: 40,
                color: Colors.indigo.shade700,
              ),
            ],
          ),
          const SizedBox(height: 24),
          Text(
            loadingMessage,
            style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: Colors.grey[800],
                ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            'This may take a moment',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Colors.grey[500],
                ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  Widget _buildErrorView() {
    return FadeTransition(
      opacity: _fadeAnimation,
      child: Container(
        constraints: const BoxConstraints(maxWidth: 500),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: Colors.red[50],
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.error_outline_rounded,
                size: 64,
                color: Colors.red[400],
              ),
            ),
            const SizedBox(height: 24),
            Text(
              'Oops! Something went wrong',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: Colors.grey[800],
                  ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 12),
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: Colors.grey[50],
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: Colors.grey[300]!),
              ),
              child: Text(
                error!,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Colors.grey[700],
                    ),
                textAlign: TextAlign.center,
              ),
            ),
            const SizedBox(height: 24),
            if (fileUrl != null && _isGoogleDriveUrl(fileUrl!)) ...[
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  icon: const Icon(Icons.refresh_rounded),
                  label: const Text('Try Again'),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 24,
                      vertical: 16,
                    ),
                    backgroundColor: Colors.indigo,
                    foregroundColor: Colors.white,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onPressed: _signInAndLoadDrive,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildReadyView() {
    return FadeTransition(
      opacity: _fadeAnimation,
      child: Container(
        constraints: const BoxConstraints(maxWidth: 600),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(24),
              child: Image.asset(
                'assets/logo/document.png',
                fit: BoxFit.